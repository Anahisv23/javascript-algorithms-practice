3b6bc28a497a147fa25816338de20079
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DoublyLinkedListNode = require('./DoublyLinkedListNode');

var _DoublyLinkedListNode2 = _interopRequireDefault(_DoublyLinkedListNode);

var _Comparator = require('../../utils/Comparator');

var _Comparator2 = _interopRequireDefault(_Comparator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DoublyLinkedList = function () {
    /**
     * @param {Function} [comparatorFunction]
     */
    function DoublyLinkedList(comparatorFunction) {
        _classCallCheck(this, DoublyLinkedList);

        /** @var DoublyLinkedListNode */
        this.head = null;

        /** @var DoublyLinkedListNode */
        this.tail = null;

        this.compare = new _Comparator2.default(comparatorFunction);
    }

    /**
     * @param {*} value
     * @return {DoublyLinkedList}
     */


    _createClass(DoublyLinkedList, [{
        key: 'prepend',
        value: function prepend(value) {
            // Make new node to be a head.
            var newNode = new _DoublyLinkedListNode2.default(value, null, this.head);

            // If there is head, then it won't be head anymore.
            // Therefore, make its previous reference to be new node (new head).
            // Then mark the new node as head
            if (this.head) {
                this.head.previous = newNode;
            }
            this.head = newNode;

            // If there is no tail yet let's make new node a tail.
            if (!this.tail) {
                this.tail = newNode;
            }

            return this;
        }

        /**
         * @param {*} value
         * @return {DoublyLinkedListNode}
         */

    }, {
        key: 'append',
        value: function append(value) {
            // Make new node to be a tail.
            var newNode = new _DoublyLinkedListNode2.default(value, this.tail, null);

            // If there is tail, then it won't be tail anymore.
            // Therefore, make its next reference to be new node (new tail).
            // Then mark the new node as tail
            if (this.tail) {
                this.tail.next = newNode;
            }
            this.tail = newNode;

            // If there is no head yet let's make new node a head.
            if (!this.head) {
                this.head = newNode;
            }

            return this;
        }

        /**
         * @param {*} value
         * @return {DoublyLinkedListNode}
         */

    }, {
        key: 'delete',
        value: function _delete(value) {
            if (!this.head) {
                return null;
            }

            var deletedNode = null;
            var currentNode = this.head;

            while (currentNode) {
                if (this.compare.equal(currentNode.value, value)) {
                    deletedNode = currentNode;

                    if (currentNode.next === null && currentNode.previous === null) {
                        this.head = null;
                        this.tail = null;
                    } else if (currentNode.next === null) {
                        currentNode.previous.next = null;
                        this.tail = currentNode.previous;
                    } else if (currentNode.previous === null) {
                        currentNode.next.previous = null;
                        this.head = currentNode.next;
                    } else {
                        currentNode.previous.next = currentNode.next;
                        currentNode.next.previous = currentNode.previous;
                    }
                }
                currentNode = currentNode.next;
            }

            return deletedNode;
        }

        /**
         * @param {Object} findParams
         * @param {*} findParams.value
         * @param {function} [findParams.callback]
         * @return {DoublyLinkedListNode}
         */

    }, {
        key: 'find',
        value: function find(_ref) {
            var _ref$value = _ref.value,
                value = _ref$value === undefined ? undefined : _ref$value,
                _ref$callback = _ref.callback,
                callback = _ref$callback === undefined ? undefined : _ref$callback;

            if (!this.head) {
                return null;
            }

            var currentNode = this.head;

            while (currentNode) {
                // If callback is specified then try to find node by callback.
                if (callback && callback(currentNode.value)) {
                    return currentNode;
                }

                // If value is specified then try to compare by value.
                if (value !== undefined && this.compare.equal(currentNode.value, value)) {
                    return currentNode;
                }

                currentNode = currentNode.next;
            }

            return null;
        }

        /**
         * @return {DoublyLinkedListNode}
         */

    }, {
        key: 'deleteTail',
        value: function deleteTail() {
            if (!this.tail) {
                return null;
            }

            if (this.head === this.tail) {
                // If There is only one node in linked list.
                var _deletedTail = this.tail;
                this.head = null;
                this.tail = null;

                return _deletedTail;
            }

            // If there are many nodes in linked list.
            var deletedTail = this.tail;

            this.tail = this.tail.previous;
            this.tail.next = null;

            return deletedTail;
        }

        /**
         * @return {DoublyLinkedListNode}
         */

    }, {
        key: 'deleteHead',
        value: function deleteHead() {
            if (!this.head) {
                return null;
            }

            var deletedHead = this.head;
            if (this.head.next) {
                // If There are many nodes in linked list.
                this.head = this.head.next;
                this.head.previous = null;
            } else {
                // If There is only one node in linked list.
                this.head = null;
                this.tail = null;
            }

            return deletedHead;
        }

        /**
         * @return {DoublyLinkedListNode[]}
         */

    }, {
        key: 'toArray',
        value: function toArray() {
            var nodes = [];

            var currentNode = this.head;
            while (currentNode) {
                nodes.push(currentNode);
                currentNode = currentNode.next;
            }

            return nodes;
        }

        /**
         * @param {*[]} values - Array of values that need to be converted to linked list.
         * @return {DoublyLinkedList}
         */

    }, {
        key: 'fromArray',
        value: function fromArray(values) {
            var _this = this;

            values.forEach(function (value) {
                return _this.append(value);
            });

            return this;
        }

        /**
         * @param {function} [callback]
         * @return {string}
         */

    }, {
        key: 'toString',
        value: function toString(callback) {
            return this.toArray().map(function (node) {
                return node.toString(callback);
            }).toString();
        }

        /**
         * Reverse a linked list.
         * @returns {DoublyLinkedList}
         */

    }, {
        key: 'reverse',
        value: function reverse() {
            var currNode = this.head;
            var prevNode = null;
            var nextNode = null;

            while (currNode) {
                prevNode = currNode.previous;
                nextNode = currNode.next;
                currNode.previous = nextNode;
                currNode.next = prevNode;

                currNode = nextNode;
            }

            prevNode = this.tail;
            this.tail = this.head;
            this.head = prevNode;

            return this;
        }
    }]);

    return DoublyLinkedList;
}();

exports.default = DoublyLinkedList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkRvdWJseUxpbmtlZExpc3QuanMiXSwibmFtZXMiOlsiRG91Ymx5TGlua2VkTGlzdCIsImNvbXBhcmF0b3JGdW5jdGlvbiIsImhlYWQiLCJ0YWlsIiwiY29tcGFyZSIsIkNvbXBhcmF0b3IiLCJ2YWx1ZSIsIm5ld05vZGUiLCJEb3VibHlMaW5rZWRMaXN0Tm9kZSIsInByZXZpb3VzIiwibmV4dCIsImRlbGV0ZWROb2RlIiwiY3VycmVudE5vZGUiLCJlcXVhbCIsInVuZGVmaW5lZCIsImNhbGxiYWNrIiwiZGVsZXRlZFRhaWwiLCJkZWxldGVkSGVhZCIsIm5vZGVzIiwicHVzaCIsInZhbHVlcyIsImZvckVhY2giLCJhcHBlbmQiLCJ0b0FycmF5IiwibWFwIiwibm9kZSIsInRvU3RyaW5nIiwiY3Vyck5vZGUiLCJwcmV2Tm9kZSIsIm5leHROb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7Ozs7O0lBRXFCQSxnQjtBQUNqQjs7O0FBR0EsOEJBQVlDLGtCQUFaLEVBQWdDO0FBQUE7O0FBQzVCO0FBQ0EsYUFBS0MsSUFBTCxHQUFZLElBQVo7O0FBRUE7QUFDQSxhQUFLQyxJQUFMLEdBQVksSUFBWjs7QUFFQSxhQUFLQyxPQUFMLEdBQWUsSUFBSUMsb0JBQUosQ0FBZUosa0JBQWYsQ0FBZjtBQUNIOztBQUVEOzs7Ozs7OztnQ0FJUUssSyxFQUFPO0FBQ1g7QUFDQSxnQkFBTUMsVUFBVSxJQUFJQyw4QkFBSixDQUF5QkYsS0FBekIsRUFBZ0MsSUFBaEMsRUFBc0MsS0FBS0osSUFBM0MsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksS0FBS0EsSUFBVCxFQUFlO0FBQ1gscUJBQUtBLElBQUwsQ0FBVU8sUUFBVixHQUFxQkYsT0FBckI7QUFDSDtBQUNELGlCQUFLTCxJQUFMLEdBQVlLLE9BQVo7O0FBRUE7QUFDQSxnQkFBSSxDQUFDLEtBQUtKLElBQVYsRUFBZ0I7QUFDWixxQkFBS0EsSUFBTCxHQUFZSSxPQUFaO0FBQ0g7O0FB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R0FBZUMsR0FBZixDQUFtQjtBQUFBLHVCQUFRQyxLQUFLQyxRQUFMLENBQWNYLFFBQWQsQ0FBUjtBQUFBLGFBQW5CLEVBQW9EVyxRQUFwRCxFQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7a0NBSVU7QUFDTixnQkFBSUMsV0FBVyxLQUFLekIsSUFBcEI7QUFDQSxnQkFBSTBCLFdBQVcsSUFBZjtBQUNBLGdCQUFJQyxXQUFXLElBQWY7O0FBRUEsbUJBQU9GLFFBQVAsRUFBaUI7QUFDYkMsMkJBQVdELFNBQVNsQixRQUFwQjtBQUNBb0IsMkJBQVdGLFNBQVNqQixJQUFwQjtBQUNBaUIseUJBQVNsQixRQUFULEdBQW9Cb0IsUUFBcEI7QUFDQUYseUJBQVNqQixJQUFULEdBQWdCa0IsUUFBaEI7O0FBRUFELDJCQUFXRSxRQUFYO0FBQ0g7O0FBRURELHVCQUFXLEtBQUt6QixJQUFoQjtBQUNBLGlCQUFLQSxJQUFMLEdBQVksS0FBS0QsSUFBakI7QUFDQSxpQkFBS0EsSUFBTCxHQUFZMEIsUUFBWjs7QUFFQSxtQkFBTyxJQUFQO0FBQ0g7Ozs7OztrQkE1T2dCNUIsZ0IiLCJmaWxlIjoiRG91Ymx5TGlua2VkTGlzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEb3VibHlMaW5rZWRMaXN0Tm9kZSBmcm9tICcuL0RvdWJseUxpbmtlZExpc3ROb2RlJztcbmltcG9ydCBDb21wYXJhdG9yIGZyb20gJy4uLy4uL3V0aWxzL0NvbXBhcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VibHlMaW5rZWRMaXN0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvckZ1bmN0aW9uXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3JGdW5jdGlvbikge1xuICAgICAgICAvKiogQHZhciBEb3VibHlMaW5rZWRMaXN0Tm9kZSAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdmFyIERvdWJseUxpbmtlZExpc3ROb2RlICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jb21wYXJlID0gbmV3IENvbXBhcmF0b3IoY29tcGFyYXRvckZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7RG91Ymx5TGlua2VkTGlzdH1cbiAgICAgKi9cbiAgICBwcmVwZW5kKHZhbHVlKSB7XG4gICAgICAgIC8vIE1ha2UgbmV3IG5vZGUgdG8gYmUgYSBoZWFkLlxuICAgICAgICBjb25zdCBuZXdOb2RlID0gbmV3IERvdWJseUxpbmtlZExpc3ROb2RlKHZhbHVlLCBudWxsLCB0aGlzLmhlYWQpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGhlYWQsIHRoZW4gaXQgd29uJ3QgYmUgaGVhZCBhbnltb3JlLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIG1ha2UgaXRzIHByZXZpb3VzIHJlZmVyZW5jZSB0byBiZSBuZXcgbm9kZSAobmV3IGhlYWQpLlxuICAgICAgICAvLyBUaGVuIG1hcmsgdGhlIG5ldyBub2RlIGFzIGhlYWRcbiAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbmV3Tm9kZTtcbiAgICAgICAgfSBcbiAgICAgICAgdGhpcy5oZWFkID0gbmV3Tm9kZTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB0YWlsIHlldCBsZXQncyBtYWtlIG5ldyBub2RlIGEgdGFpbC5cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtEb3VibHlMaW5rZWRMaXN0Tm9kZX1cbiAgICAgKi9cbiAgICBhcHBlbmQodmFsdWUpIHtcbiAgICAgICAgLy8gTWFrZSBuZXcgbm9kZSB0byBiZSBhIHRhaWwuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgRG91Ymx5TGlua2VkTGlzdE5vZGUodmFsdWUsIHRoaXMudGFpbCwgbnVsbCk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgdGFpbCwgdGhlbiBpdCB3b24ndCBiZSB0YWlsIGFueW1vcmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgbWFrZSBpdHMgbmV4dCByZWZlcmVuY2UgdG8gYmUgbmV3IG5vZGUgKG5ldyB0YWlsKS5cbiAgICAgICAgLy8gVGhlbiBtYXJrIHRoZSBuZXcgbm9kZSBhcyB0YWlsXG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGhlYWQgeWV0IGxldCdzIG1ha2UgbmV3IG5vZGUgYSBoZWFkLlxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtEb3VibHlMaW5rZWRMaXN0Tm9kZX1cbiAgICAgKi9cbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlbGV0ZWROb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZS5lcXVhbChjdXJyZW50Tm9kZS52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZE5vZGUgPSBjdXJyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5uZXh0ID09PSBudWxsICYmIGN1cnJlbnROb2RlLnByZXZpb3VzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnROb2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucHJldmlvdXMubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnROb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE5vZGUucHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubmV4dC5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wcmV2aW91cy5uZXh0ID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubmV4dC5wcmV2aW91cyA9IGN1cnJlbnROb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWxldGVkTm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmluZFBhcmFtc1xuICAgICAqIEBwYXJhbSB7Kn0gZmluZFBhcmFtcy52YWx1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmaW5kUGFyYW1zLmNhbGxiYWNrXVxuICAgICAqIEByZXR1cm4ge0RvdWJseUxpbmtlZExpc3ROb2RlfVxuICAgICAqL1xuXG4gICAgZmluZCh7IHZhbHVlID0gdW5kZWZpbmVkLCBjYWxsYmFjayA9IHVuZGVmaW5lZCB9KSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMuaGVhZDtcblxuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIElmIGNhbGxiYWNrIGlzIHNwZWNpZmllZCB0aGVuIHRyeSB0byBmaW5kIG5vZGUgYnkgY2FsbGJhY2suXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2soY3VycmVudE5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBzcGVjaWZpZWQgdGhlbiB0cnkgdG8gY29tcGFyZSBieSB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29tcGFyZS5lcXVhbChjdXJyZW50Tm9kZS52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtEb3VibHlMaW5rZWRMaXN0Tm9kZX1cbiAgICAgKi9cbiAgICBkZWxldGVUYWlsKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIC8vIElmIFRoZXJlIGlzIG9ubHkgb25lIG5vZGUgaW4gbGlua2VkIGxpc3QuXG4gICAgICAgICAgICBjb25zdCBkZWxldGVkVGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlZFRhaWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbWFueSBub2RlcyBpbiBsaW5rZWQgbGlzdC5cbiAgICAgICAgY29uc3QgZGVsZXRlZFRhaWwgPSB0aGlzLnRhaWw7XG5cbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZpb3VzO1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWRUYWlsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0RvdWJseUxpbmtlZExpc3ROb2RlfVxuICAgICAqL1xuICAgIGRlbGV0ZUhlYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRIZWFkID0gdGhpcy5oZWFkO1xuICAgICAgICBpZiAodGhpcy5oZWFkLm5leHQpIHtcbiAgICAgICAgICAgIC8vIElmIFRoZXJlIGFyZSBtYW55IG5vZGVzIGluIGxpbmtlZCBsaXN0LlxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgVGhlcmUgaXMgb25seSBvbmUgbm9kZSBpbiBsaW5rZWQgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWRIZWFkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0RvdWJseUxpbmtlZExpc3ROb2RlW119XG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geypbXX0gdmFsdWVzIC0gQXJyYXkgb2YgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gbGlua2VkIGxpc3QuXG4gICAgICogQHJldHVybiB7RG91Ymx5TGlua2VkTGlzdH1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHRoaXMuYXBwZW5kKHZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZyhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubWFwKG5vZGUgPT4gbm9kZS50b1N0cmluZyhjYWxsYmFjaykpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZSBhIGxpbmtlZCBsaXN0LlxuICAgICAqIEByZXR1cm5zIHtEb3VibHlMaW5rZWRMaXN0fVxuICAgICAqL1xuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIGxldCBjdXJyTm9kZSA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IHByZXZOb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoY3Vyck5vZGUpIHtcbiAgICAgICAgICAgIHByZXZOb2RlID0gY3Vyck5vZGUucHJldmlvdXM7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGN1cnJOb2RlLm5leHQ7XG4gICAgICAgICAgICBjdXJyTm9kZS5wcmV2aW91cyA9IG5leHROb2RlO1xuICAgICAgICAgICAgY3Vyck5vZGUubmV4dCA9IHByZXZOb2RlXG5cbiAgICAgICAgICAgIGN1cnJOb2RlID0gbmV4dE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2Tm9kZSA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuICAgICAgICB0aGlzLmhlYWQgPSBwcmV2Tm9kZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59Il19