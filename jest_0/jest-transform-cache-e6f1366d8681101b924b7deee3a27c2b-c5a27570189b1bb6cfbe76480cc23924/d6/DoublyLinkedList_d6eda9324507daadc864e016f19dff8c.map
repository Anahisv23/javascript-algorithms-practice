{"version":3,"sources":["DoublyLinkedList.js"],"names":["DoublyLinkedList","comparatorFunction","head","tail","compare","Comparator","value","newNode","DoublyLinkedListNode","previous","next","deletedNode","currentNode","equal","undefined","callback","deletedTail","deletedHead","nodes","push","values","forEach","append","toArray","map","node","toString","currNode","prevNode","nextNode"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;IAEqBA,gB;AACjB;;;AAGA,8BAAYC,kBAAZ,EAAgC;AAAA;;AAC5B;AACA,aAAKC,IAAL,GAAY,IAAZ;;AAEA;AACA,aAAKC,IAAL,GAAY,IAAZ;;AAEA,aAAKC,OAAL,GAAe,IAAIC,oBAAJ,CAAeJ,kBAAf,CAAf;AACH;;AAED;;;;;;;;gCAIQK,K,EAAO;AACX;AACA,gBAAMC,UAAU,IAAIC,8BAAJ,CAAyBF,KAAzB,EAAgC,IAAhC,EAAsC,KAAKJ,IAA3C,CAAhB;;AAEA;AACA;AACA;AACA,gBAAI,KAAKA,IAAT,EAAe;AACX,qBAAKA,IAAL,CAAUO,QAAV,GAAqBF,OAArB;AACH;AACD,iBAAKL,IAAL,GAAYK,OAAZ;;AAEA;AACA,gBAAI,CAAC,KAAKJ,IAAV,EAAgB;AACZ,qBAAKA,IAAL,GAAYI,OAAZ;AACH;;AAED,mBAAO,IAAP;AACH;;AAED;;;;;;;+BAIOD,K,EAAO;AACV;AACA,gBAAMC,UAAU,IAAIC,8BAAJ,CAAyBF,KAAzB,EAAgC,KAAKH,IAArC,EAA2C,IAA3C,CAAhB;;AAEA;AACA;AACA;AACA,gBAAI,KAAKA,IAAT,EAAe;AACX,qBAAKA,IAAL,CAAUO,IAAV,GAAiBH,OAAjB;AACH;AACD,iBAAKJ,IAAL,GAAYI,OAAZ;;AAEA;AACA,gBAAI,CAAC,KAAKL,IAAV,EAAgB;AACZ,qBAAKA,IAAL,GAAYK,OAAZ;AACH;;AAED,mBAAO,IAAP;AACH;;AAED;;;;;;;gCAIOD,K,EAAO;AACV,gBAAI,CAAC,KAAKJ,IAAV,EAAgB;AACZ,uBAAO,IAAP;AACH;;AAED,gBAAIS,cAAc,IAAlB;AACA,gBAAIC,cAAc,KAAKV,IAAvB;;AAEA,mBAAOU,WAAP,EAAoB;AAChB,oBAAI,KAAKR,OAAL,CAAaS,KAAb,CAAmBD,YAAYN,KAA/B,EAAsCA,KAAtC,CAAJ,EAAkD;AAC9CK,kCAAcC,WAAd;;AAEA,wBAAIA,YAAYF,IAAZ,KAAqB,IAArB,IAA6BE,YAAYH,QAAZ,KAAyB,IAA1D,EAAgE;AAC5D,6BAAKP,IAAL,GAAY,IAAZ;AACA,6BAAKC,IAAL,GAAY,IAAZ;AACH,qBAHD,MAIK,IAAIS,YAAYF,IAAZ,KAAqB,IAAzB,EAA+B;AAChCE,oCAAYH,QAAZ,CAAqBC,IAArB,GAA4B,IAA5B;AACA,6BAAKP,IAAL,GAAYS,YAAYH,QAAxB;AACH,qBAHI,MAIA,IAAIG,YAAYH,QAAZ,KAAyB,IAA7B,EAAmC;AACpCG,oCAAYF,IAAZ,CAAiBD,QAAjB,GAA4B,IAA5B;AACA,6BAAKP,IAAL,GAAYU,YAAYF,IAAxB;AACH,qBAHI,MAIA;AACDE,oCAAYH,QAAZ,CAAqBC,IAArB,GAA4BE,YAAYF,IAAxC;AACAE,oCAAYF,IAAZ,CAAiBD,QAAjB,GAA4BG,YAAYH,QAAxC;AACH;AACJ;AACDG,8BAAcA,YAAYF,IAA1B;AACH;;AAED,mBAAOC,WAAP;AACH;;AAED;;;;;;;;;mCAOkD;AAAA,kCAA3CL,KAA2C;AAAA,gBAA3CA,KAA2C,8BAAnCQ,SAAmC;AAAA,qCAAxBC,QAAwB;AAAA,gBAAxBA,QAAwB,iCAAbD,SAAa;;AAC9C,gBAAI,CAAC,KAAKZ,IAAV,EAAgB;AACZ,uBAAO,IAAP;AACH;;AAED,gBAAIU,cAAc,KAAKV,IAAvB;;AAEA,mBAAOU,WAAP,EAAoB;AAChB;AACA,oBAAIG,YAAYA,SAASH,YAAYN,KAArB,CAAhB,EAA6C;AACzC,2BAAOM,WAAP;AACH;;AAED;AACA,oBAAIN,UAAUQ,SAAV,IAAuB,KAAKV,OAAL,CAAaS,KAAb,CAAmBD,YAAYN,KAA/B,EAAsCA,KAAtC,CAA3B,EAAyE;AACrE,2BAAOM,WAAP;AACH;;AAEDA,8BAAcA,YAAYF,IAA1B;AACH;;AAED,mBAAO,IAAP;AACH;;AAED;;;;;;qCAGa;AACT,gBAAI,CAAC,KAAKP,IAAV,EAAgB;AACZ,uBAAO,IAAP;AACH;;AAED,gBAAI,KAAKD,IAAL,KAAc,KAAKC,IAAvB,EAA6B;AACzB;AACA,oBAAMa,eAAc,KAAKb,IAAzB;AACA,qBAAKD,IAAL,GAAY,IAAZ;AACA,qBAAKC,IAAL,GAAY,IAAZ;;AAEA,uBAAOa,YAAP;AACH;;AAED;AACA,gBAAMA,cAAc,KAAKb,IAAzB;;AAEA,iBAAKA,IAAL,GAAY,KAAKA,IAAL,CAAUM,QAAtB;AACA,iBAAKN,IAAL,CAAUO,IAAV,GAAiB,IAAjB;;AAEA,mBAAOM,WAAP;AACH;;AAED;;;;;;qCAGa;AACT,gBAAI,CAAC,KAAKd,IAAV,EAAgB;AACZ,uBAAO,IAAP;AACH;;AAED,gBAAMe,cAAc,KAAKf,IAAzB;AACA,gBAAI,KAAKA,IAAL,CAAUQ,IAAd,EAAoB;AAChB;AACA,qBAAKR,IAAL,GAAY,KAAKA,IAAL,CAAUQ,IAAtB;AACA,qBAAKR,IAAL,CAAUO,QAAV,GAAqB,IAArB;AACH,aAJD,MAIO;AACH;AACA,qBAAKP,IAAL,GAAY,IAAZ;AACA,qBAAKC,IAAL,GAAY,IAAZ;AACH;;AAED,mBAAOc,WAAP;AACH;;AAED;;;;;;kCAGU;AACN,gBAAMC,QAAQ,EAAd;;AAEA,gBAAIN,cAAc,KAAKV,IAAvB;AACA,mBAAOU,WAAP,EAAoB;AAChBM,sBAAMC,IAAN,CAAWP,WAAX;AACAA,8BAAcA,YAAYF,IAA1B;AACH;;AAED,mBAAOQ,KAAP;AACH;;AAED;;;;;;;kCAIUE,M,EAAQ;AAAA;;AACdA,mBAAOC,OAAP,CAAe;AAAA,uBAAS,MAAKC,MAAL,CAAYhB,KAAZ,CAAT;AAAA,aAAf;;AAEA,mBAAO,IAAP;AACH;;AAED;;;;;;;iCAISS,Q,EAAU;AACf,mBAAO,KAAKQ,OAAL,GAAeC,GAAf,CAAmB;AAAA,uBAAQC,KAAKC,QAAL,CAAcX,QAAd,CAAR;AAAA,aAAnB,EAAoDW,QAApD,EAAP;AACH;;AAED;;;;;;;kCAIU;AACN,gBAAIC,WAAW,KAAKzB,IAApB;AACA,gBAAI0B,WAAW,IAAf;AACA,gBAAIC,WAAW,IAAf;;AAEA,mBAAOF,QAAP,EAAiB;AACbC,2BAAWD,SAASlB,QAApB;AACAoB,2BAAWF,SAASjB,IAApB;AACAiB,yBAASlB,QAAT,GAAoBoB,QAApB;AACAF,yBAASjB,IAAT,GAAgBkB,QAAhB;;AAEAD,2BAAWE,QAAX;AACH;;AAEDD,uBAAW,KAAKzB,IAAhB;AACA,iBAAKA,IAAL,GAAY,KAAKD,IAAjB;AACA,iBAAKA,IAAL,GAAY0B,QAAZ;;AAEA,mBAAO,IAAP;AACH;;;;;;kBA5OgB5B,gB","file":"DoublyLinkedList.js","sourcesContent":["import DoublyLinkedListNode from './DoublyLinkedListNode';\nimport Comparator from '../../utils/Comparator';\n\nexport default class DoublyLinkedList {\n    /**\n     * @param {Function} [comparatorFunction]\n     */\n    constructor(comparatorFunction) {\n        /** @var DoublyLinkedListNode */\n        this.head = null;\n\n        /** @var DoublyLinkedListNode */\n        this.tail = null;\n\n        this.compare = new Comparator(comparatorFunction);\n    }\n\n    /**\n     * @param {*} value\n     * @return {DoublyLinkedList}\n     */\n    prepend(value) {\n        // Make new node to be a head.\n        const newNode = new DoublyLinkedListNode(value, null, this.head);\n\n        // If there is head, then it won't be head anymore.\n        // Therefore, make its previous reference to be new node (new head).\n        // Then mark the new node as head\n        if (this.head) {\n            this.head.previous = newNode;\n        } \n        this.head = newNode;\n\n        // If there is no tail yet let's make new node a tail.\n        if (!this.tail) {\n            this.tail = newNode;\n        }\n        \n        return this;\n    }\n\n    /**\n     * @param {*} value\n     * @return {DoublyLinkedListNode}\n     */\n    append(value) {\n        // Make new node to be a tail.\n        const newNode = new DoublyLinkedListNode(value, this.tail, null);\n\n        // If there is tail, then it won't be tail anymore.\n        // Therefore, make its next reference to be new node (new tail).\n        // Then mark the new node as tail\n        if (this.tail) {\n            this.tail.next = newNode;\n        }\n        this.tail = newNode;\n\n        // If there is no head yet let's make new node a head.\n        if (!this.head) {\n            this.head = newNode;\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {*} value\n     * @return {DoublyLinkedListNode}\n     */\n    delete(value) {\n        if (!this.head) {\n            return null;\n        }\n\n        let deletedNode = null;\n        let currentNode = this.head;\n\n        while (currentNode) {\n            if (this.compare.equal(currentNode.value, value)) {\n                deletedNode = currentNode;\n\n                if (currentNode.next === null && currentNode.previous === null) {\n                    this.head = null;\n                    this.tail = null;\n                }\n                else if (currentNode.next === null) {\n                    currentNode.previous.next = null;\n                    this.tail = currentNode.previous;\n                } \n                else if (currentNode.previous === null) {\n                    currentNode.next.previous = null;\n                    this.head = currentNode.next;\n                }\n                else {\n                    currentNode.previous.next = currentNode.next;\n                    currentNode.next.previous = currentNode.previous;\n                }\n            }\n            currentNode = currentNode.next;\n        }\n\n        return deletedNode;\n    }\n\n    /**\n     * @param {Object} findParams\n     * @param {*} findParams.value\n     * @param {function} [findParams.callback]\n     * @return {DoublyLinkedListNode}\n     */\n\n    find({ value = undefined, callback = undefined }) {\n        if (!this.head) {\n            return null;\n        }\n\n        let currentNode = this.head;\n\n        while (currentNode) {\n            // If callback is specified then try to find node by callback.\n            if (callback && callback(currentNode.value)) {\n                return currentNode;\n            }\n\n            // If value is specified then try to compare by value.\n            if (value !== undefined && this.compare.equal(currentNode.value, value)) {\n                return currentNode;\n            }\n\n            currentNode = currentNode.next;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return {DoublyLinkedListNode}\n     */\n    deleteTail() {\n        if (!this.tail) {\n            return null;\n        }\n\n        if (this.head === this.tail) {\n            // If There is only one node in linked list.\n            const deletedTail = this.tail;\n            this.head = null;\n            this.tail = null;\n\n            return deletedTail;\n        }\n\n        // If there are many nodes in linked list.\n        const deletedTail = this.tail;\n\n        this.tail = this.tail.previous;\n        this.tail.next = null;\n\n        return deletedTail;\n    }\n\n    /**\n     * @return {DoublyLinkedListNode}\n     */\n    deleteHead() {\n        if (!this.head) {\n            return null;\n        }\n\n        const deletedHead = this.head;\n        if (this.head.next) {\n            // If There are many nodes in linked list.\n            this.head = this.head.next;\n            this.head.previous = null;\n        } else {\n            // If There is only one node in linked list.\n            this.head = null;\n            this.tail = null;\n        }\n\n        return deletedHead;\n    }\n\n    /**\n     * @return {DoublyLinkedListNode[]}\n     */\n    toArray() {\n        const nodes = [];\n        \n        let currentNode = this.head;\n        while (currentNode) {\n            nodes.push(currentNode);\n            currentNode = currentNode.next;\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @param {*[]} values - Array of values that need to be converted to linked list.\n     * @return {DoublyLinkedList}\n     */\n    fromArray(values) {\n        values.forEach(value => this.append(value));\n\n        return this;\n    }\n\n    /**\n     * @param {function} [callback]\n     * @return {string}\n     */\n    toString(callback) {\n        return this.toArray().map(node => node.toString(callback)).toString();\n    }\n\n    /**\n     * Reverse a linked list.\n     * @returns {DoublyLinkedList}\n     */\n    reverse() {\n        let currNode = this.head;\n        let prevNode = null;\n        let nextNode = null;\n\n        while (currNode) {\n            prevNode = currNode.previous;\n            nextNode = currNode.next;\n            currNode.previous = nextNode;\n            currNode.next = prevNode\n\n            currNode = nextNode;\n        }\n\n        prevNode = this.tail;\n        this.tail = this.head;\n        this.head = prevNode;\n\n        return this;\n    }\n}"]}