1b1db54e32e42b807f652438fd0ed699
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LinkedListNode = require("./LinkedListNode");

var _LinkedListNode2 = _interopRequireDefault(_LinkedListNode);

var _Comparator = require("../../utils/Comparator");

var _Comparator2 = _interopRequireDefault(_Comparator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LinkedList = function () {
    /**
     * @param {Function} [comparatorFunction]
     */
    function LinkedList(comparatorFunction) {
        _classCallCheck(this, LinkedList);

        /** @var LinkedListNode */
        this.head = null;

        /** @var LinkedListNode */
        this.tail = null;

        this.compare = new _Comparator2.default(comparatorFunction);
    }

    /**
     * @param {*} value
     * @return {LinkedList}
     */


    _createClass(LinkedList, [{
        key: "prepend",
        value: function prepend(value) {
            var newNode = new _LinkedListNode2.default(value);

            // If there is no head yet let's make new node a head.
            if (!this.head) {
                this.head = newNode;
                this.tail = newNode;

                return this;
            }

            // Attach new node to the head of linked list.
            newNode.next = this.head;
            this.head = newNode;

            return this;
        }

        /**
         * @param {*} value
         * @return {LinkedList}
         */

    }, {
        key: "append",
        value: function append(value) {
            var newNode = new _LinkedListNode2.default(value);

            // If there is no head yet let's make new node a head.
            if (!this.head) {
                this.head = newNode;
                this.tail = newNode;

                return this;
            }

            // Attach new node to the end of linked list.
            this.tail.next = newNode;
            this.tail = newNode;

            return this;
        }

        /**
         * @param {*} value
         * @return {LinkedListNode}
         */

    }, {
        key: "delete",
        value: function _delete(value) {
            if (!this.head) {
                return null;
            }

            var deletedNode = null;

            // If the head must be deleted then make next node that is differ
            // from the head to be a new head.
            while (this.head && this.compare.equal(this.head.value, value)) {
                deletedNode = this.head;
                this.head = this.head.next;
            }

            var currentNode = this.head;

            if (currentNode !== null) {
                // If next node must be deleted then make next node to be a next next one.
                while (currentNode.next) {
                    if (this.compare.equal(currentNode.next.value, value)) {
                        deletedNode = currentNode.next;
                        currentNode.next = currentNode.next.next;
                    } else {
                        currentNode = currentNode.next;
                    }
                }
            }

            if (this.compare.equal(this.tail.value, value)) {
                this.tail = currentNode;
            }

            return deletedNode;
        }

        /**
         * @param {Object} findParams
         * @param {*} findParams.value
         * @param {function} [findParams.callback]
         * @return {LinkedListNode}
         */

    }, {
        key: "find",
        value: function find(_ref) {
            var _ref$value = _ref.value,
                value = _ref$value === undefined ? undefined : _ref$value,
                _ref$callback = _ref.callback,
                callback = _ref$callback === undefined ? undefined : _ref$callback;

            if (!this.head) {
                return null;
            }

            var currentNode = this.head;

            while (currentNode) {
                // If callback is specified then try to find node by callback.
                if (callback && callback(currentNode.value)) {
                    return currentNode;
                }

                // If value is specified then try to compare by value.
                if (value && this.compare.equal(currentNode.value, value)) {
                    return currentNode;
                }

                currentNode = currentNode.next;
            }

            return null;
        }

        /**
         * @return {LinkedListNode}
         */

    }, {
        key: "deleteTail",
        value: function deleteTail() {
            var deletedTail = this.tail;

            if (this.head === this.tail) {
                // There is only one node in linked list.
                this.head = null;
                this.tail = null;

                return deletedTail;
            }

            // If there are many nodes in linked list
            // rewind to the last node and delete next link for the node before the last one.
            var currentNode = this.head;
            while (currentNode.next) {
                if (!currentNode.next.next) {
                    currentNode.next = null;
                } else {
                    currentNode = currentNode.next;
                }
            }

            this.tail = currentNode;

            return deletedTail;
        }

        /**
         * @return {LinkedListNode}
         */

    }, {
        key: "deleteHead",
        value: function deleteHead() {
            if (!this.head) {
                return null;
            }

            var deletedHead = this.head;

            if (this.head.next) {
                this.head = this.head.next;
            } else {
                this.head = null;
                this.tail = null;
            }

            return deletedHead;
        }

        /**
         * @param {*[]} values - Array of vaules that need to be converted to linked list.
         * @return {LinkedList}
         */

    }, {
        key: "fromArray",
        value: function fromArray(values) {
            var _this = this;

            values.forEach(function (value) {
                return _this.append(value);
            });

            return this;
        }

        /**
         * @return {LinkedListNode[]}
         */

    }, {
        key: "toArray",
        value: function toArray() {
            var nodes = [];

            var currentNode = this.head;
            while (currentNode) {
                nodes.push(currentNode);
                currentNode = currentNode.next;
            }

            return nodes;
        }

        /**
         * @param {function} [callback]
         * @return {string}
         */

    }, {
        key: "toString",
        value: function toString(callback) {
            return this.toArray().map(function (node) {
                return node.toString(callback);
            }).toString();
        }

        /**
         * Reverse a linked list.
         * @returns {LinkedList}
         */

    }, {
        key: "reverse",
        value: function reverse() {
            var currNode = this.head;
            var prevNode = null;
            var nextNode = null;

            while (currNode) {
                // Store next node.
                nextNode = currNode.next;

                // Change next node of the current node so it would link to previous node.
                currNode.next = prevNode;

                // Move prevNode and currNode nodes one step forward.
                prevNode = currNode;
                currNode = nextNode;
            }

            // Reset head and tail.
            this.tail = this.head;
            this.head = prevNode;

            return this;
        }
    }]);

    return LinkedList;
}();

exports.default = LinkedList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxpbmtlZExpc3QuanMiXSwibmFtZXMiOlsiTGlua2VkTGlzdCIsImNvbXBhcmF0b3JGdW5jdGlvbiIsImhlYWQiLCJ0YWlsIiwiY29tcGFyZSIsIkNvbXBhcmF0b3IiLCJ2YWx1ZSIsIm5ld05vZGUiLCJMaW5rZWRMaXN0Tm9kZSIsIm5leHQiLCJkZWxldGVkTm9kZSIsImVxdWFsIiwiY3VycmVudE5vZGUiLCJ1bmRlZmluZWQiLCJjYWxsYmFjayIsImRlbGV0ZWRUYWlsIiwiZGVsZXRlZEhlYWQiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwiYXBwZW5kIiwibm9kZXMiLCJwdXNoIiwidG9BcnJheSIsIm1hcCIsIm5vZGUiLCJ0b1N0cmluZyIsImN1cnJOb2RlIiwicHJldk5vZGUiLCJuZXh0Tm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7OztJQUVxQkEsVTtBQUNqQjs7O0FBR0Esd0JBQVlDLGtCQUFaLEVBQWdDO0FBQUE7O0FBQzVCO0FBQ0EsYUFBS0MsSUFBTCxHQUFZLElBQVo7O0FBRUE7QUFDQSxhQUFLQyxJQUFMLEdBQVksSUFBWjs7QUFFQSxhQUFLQyxPQUFMLEdBQWUsSUFBSUMsb0JBQUosQ0FBZUosa0JBQWYsQ0FBZjtBQUNIOztBQUVEOzs7Ozs7OztnQ0FJUUssSyxFQUFPO0FBQ1gsZ0JBQU1DLFVBQVUsSUFBSUMsd0JBQUosQ0FBbUJGLEtBQW5CLENBQWhCOztBQUVBO0FBQ0EsZ0JBQUksQ0FBQyxLQUFLSixJQUFWLEVBQWdCO0FBQ1oscUJBQUtBLElBQUwsR0FBWUssT0FBWjtBQUNBLHFCQUFLSixJQUFMLEdBQVlJLE9BQVo7O0FBRUEsdUJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0FBLG9CQUFRRSxJQUFSLEdBQWUsS0FBS1AsSUFBcEI7QUFDQSxpQkFBS0EsSUFBTCxHQUFZSyxPQUFaOztBQUVBLG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7OzsrQkFJT0QsSyxFQUFPO0FBQ1YsZ0JBQU1DLFVBQVUsSUFBSUMs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QUFXLElBQWY7O0FBRUEsbUJBQU9GLFFBQVAsRUFBaUI7QUFDYjtBQUNBRSwyQkFBV0YsU0FBU2pCLElBQXBCOztBQUVBO0FBQ0FpQix5QkFBU2pCLElBQVQsR0FBZ0JrQixRQUFoQjs7QUFFQTtBQUNBQSwyQkFBV0QsUUFBWDtBQUNBQSwyQkFBV0UsUUFBWDtBQUNIOztBQUVEO0FBQ0EsaUJBQUt6QixJQUFMLEdBQVksS0FBS0QsSUFBakI7QUFDQSxpQkFBS0EsSUFBTCxHQUFZeUIsUUFBWjs7QUFFQSxtQkFBTyxJQUFQO0FBQ0g7Ozs7OztrQkE3T2dCM0IsVSIsImZpbGUiOiJMaW5rZWRMaXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmtlZExpc3ROb2RlIGZyb20gXCIuL0xpbmtlZExpc3ROb2RlXCI7XG5pbXBvcnQgQ29tcGFyYXRvciBmcm9tIFwiLi4vLi4vdXRpbHMvQ29tcGFyYXRvclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rZWRMaXN0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvckZ1bmN0aW9uXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3JGdW5jdGlvbikge1xuICAgICAgICAvKiogQHZhciBMaW5rZWRMaXN0Tm9kZSAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdmFyIExpbmtlZExpc3ROb2RlICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jb21wYXJlID0gbmV3IENvbXBhcmF0b3IoY29tcGFyYXRvckZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7TGlua2VkTGlzdH1cbiAgICAgKi9cbiAgICBwcmVwZW5kKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTGlua2VkTGlzdE5vZGUodmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGhlYWQgeWV0IGxldCdzIG1ha2UgbmV3IG5vZGUgYSBoZWFkLlxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5ld05vZGU7XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2ggbmV3IG5vZGUgdG8gdGhlIGhlYWQgb2YgbGlua2VkIGxpc3QuXG4gICAgICAgIG5ld05vZGUubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgdGhpcy5oZWFkID0gbmV3Tm9kZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7TGlua2VkTGlzdH1cbiAgICAgKi9cbiAgICBhcHBlbmQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBMaW5rZWRMaXN0Tm9kZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gaGVhZCB5ZXQgbGV0J3MgbWFrZSBuZXcgbm9kZSBhIGhlYWQuXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbmV3Tm9kZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEF0dGFjaCBuZXcgbm9kZSB0byB0aGUgZW5kIG9mIGxpbmtlZCBsaXN0LlxuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIHRoaXMudGFpbCA9IG5ld05vZGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0xpbmtlZExpc3ROb2RlfVxuICAgICAqL1xuICAgIGRlbGV0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVsZXRlZE5vZGUgPSBudWxsO1xuXG4gICAgICAgIC8vIElmIHRoZSBoZWFkIG11c3QgYmUgZGVsZXRlZCB0aGVuIG1ha2UgbmV4dCBub2RlIHRoYXQgaXMgZGlmZmVyXG4gICAgICAgIC8vIGZyb20gdGhlIGhlYWQgdG8gYmUgYSBuZXcgaGVhZC5cbiAgICAgICAgd2hpbGUgKHRoaXMuaGVhZCAmJiB0aGlzLmNvbXBhcmUuZXF1YWwodGhpcy5oZWFkLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZWROb2RlID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBuZXh0IG5vZGUgbXVzdCBiZSBkZWxldGVkIHRoZW4gbWFrZSBuZXh0IG5vZGUgdG8gYmUgYSBuZXh0IG5leHQgb25lLlxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlLmVxdWFsKGN1cnJlbnROb2RlLm5leHQudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVkTm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBjdXJyZW50Tm9kZS5uZXh0Lm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZS5lcXVhbCh0aGlzLnRhaWwudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsZXRlZE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbmRQYXJhbXNcbiAgICAgKiBAcGFyYW0geyp9IGZpbmRQYXJhbXMudmFsdWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZmluZFBhcmFtcy5jYWxsYmFja11cbiAgICAgKiBAcmV0dXJuIHtMaW5rZWRMaXN0Tm9kZX1cbiAgICAgKi9cbiAgICBmaW5kKHsgdmFsdWUgPSB1bmRlZmluZWQsIGNhbGxiYWNrID0gdW5kZWZpbmVkIH0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gSWYgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIHRoZW4gdHJ5IHRvIGZpbmQgbm9kZSBieSBjYWxsYmFjay5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjayhjdXJyZW50Tm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIHNwZWNpZmllZCB0aGVuIHRyeSB0byBjb21wYXJlIGJ5IHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY29tcGFyZS5lcXVhbChjdXJyZW50Tm9kZS52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtMaW5rZWRMaXN0Tm9kZX1cbiAgICAgKi9cbiAgICBkZWxldGVUYWlsKCkge1xuICAgICAgICBjb25zdCBkZWxldGVkVGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgbm9kZSBpbiBsaW5rZWQgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlZFRhaWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbWFueSBub2RlcyBpbiBsaW5rZWQgbGlzdFxuICAgICAgICAvLyByZXdpbmQgdG8gdGhlIGxhc3Qgbm9kZSBhbmQgZGVsZXRlIG5leHQgbGluayBmb3IgdGhlIG5vZGUgYmVmb3JlIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUubmV4dCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5uZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YWlsID0gY3VycmVudE5vZGU7XG5cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWRUYWlsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0xpbmtlZExpc3ROb2RlfVxuICAgICAqL1xuICAgIGRlbGV0ZUhlYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRIZWFkID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWxldGVkSGVhZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geypbXX0gdmFsdWVzIC0gQXJyYXkgb2YgdmF1bGVzIHRoYXQgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gbGlua2VkIGxpc3QuXG4gICAgICogQHJldHVybiB7TGlua2VkTGlzdH1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHRoaXMuYXBwZW5kKHZhbHVlKSk7XG4gICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0xpbmtlZExpc3ROb2RlW119XG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAobm9kZSA9PiBub2RlLnRvU3RyaW5nKGNhbGxiYWNrKSkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIGEgbGlua2VkIGxpc3QuXG4gICAgICogQHJldHVybnMge0xpbmtlZExpc3R9XG4gICAgICovXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgbGV0IGN1cnJOb2RlID0gdGhpcy5oZWFkO1xuICAgICAgICBsZXQgcHJldk5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChjdXJyTm9kZSkge1xuICAgICAgICAgICAgLy8gU3RvcmUgbmV4dCBub2RlLlxuICAgICAgICAgICAgbmV4dE5vZGUgPSBjdXJyTm9kZS5uZXh0O1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgbmV4dCBub2RlIG9mIHRoZSBjdXJyZW50IG5vZGUgc28gaXQgd291bGQgbGluayB0byBwcmV2aW91cyBub2RlLlxuICAgICAgICAgICAgY3Vyck5vZGUubmV4dCA9IHByZXZOb2RlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb3ZlIHByZXZOb2RlIGFuZCBjdXJyTm9kZSBub2RlcyBvbmUgc3RlcCBmb3J3YXJkLlxuICAgICAgICAgICAgcHJldk5vZGUgPSBjdXJyTm9kZTtcbiAgICAgICAgICAgIGN1cnJOb2RlID0gbmV4dE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBoZWFkIGFuZCB0YWlsLlxuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHRoaXMuaGVhZCA9IHByZXZOb2RlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuIl19