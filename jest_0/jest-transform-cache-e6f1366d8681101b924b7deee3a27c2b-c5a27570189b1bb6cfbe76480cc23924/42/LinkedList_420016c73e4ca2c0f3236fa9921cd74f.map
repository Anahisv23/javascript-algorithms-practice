{"version":3,"sources":["LinkedList.js"],"names":["LinkedList","comparatorFunction","head","tail","compare","Comparator","value","newNode","LinkedListNode","next","deletedNode","equal","currentNode","undefined","callback","deletedTail","deletedHead","values","forEach","append","nodes","push","toArray","map","node","toString","currNode","prevNode","nextNode"],"mappings":"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","file":"LinkedList.js","sourcesContent":["import LinkedListNode from \"./LinkedListNode\";\nimport Comparator from \"../../utils/Comparator\";\n\nexport default class LinkedList {\n    /**\n     * @param {Function} [comparatorFunction]\n     */\n    constructor(comparatorFunction) {\n        /** @var LinkedListNode */\n        this.head = null;\n\n        /** @var LinkedListNode */\n        this.tail = null;\n\n        this.compare = new Comparator(comparatorFunction);\n    }\n\n    /**\n     * @param {*} value\n     * @return {LinkedList}\n     */\n    prepend(value) {\n        const newNode = new LinkedListNode(value);\n\n        // If there is no head yet let's make new node a head.\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        \n            return this;\n        }\n\n        // Attach new node to the head of linked list.\n        newNode.next = this.head;\n        this.head = newNode;\n\n        return this;\n    }\n\n    /**\n     * @param {*} value\n     * @return {LinkedList}\n     */\n    append(value) {\n        const newNode = new LinkedListNode(value);\n\n        // If there is no head yet let's make new node a head.\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n\n            return this;\n        }\n        \n        // Attach new node to the end of linked list.\n        this.tail.next = newNode;\n        this.tail = newNode;\n\n        return this;\n    }\n\n    /**\n     * @param {*} value\n     * @return {LinkedListNode}\n     */\n    delete(value) {\n        if (!this.head) {\n            return null;\n        }\n\n        let deletedNode = null;\n\n        // If the head must be deleted then make next node that is differ\n        // from the head to be a new head.\n        while (this.head && this.compare.equal(this.head.value, value)) {\n            deletedNode = this.head;\n            this.head = this.head.next;\n        }\n\n        let currentNode = this.head;\n\n        if (currentNode !== null) {\n            // If next node must be deleted then make next node to be a next next one.\n            while (currentNode.next) {\n                if (this.compare.equal(currentNode.next.value, value)) {\n                    deletedNode = currentNode.next;\n                    currentNode.next = currentNode.next.next;\n                }\n                else {\n                    currentNode = currentNode.next;\n                }\n            }\n        }\n\n        if (this.compare.equal(this.tail.value, value)) {\n            this.tail = currentNode;\n        }\n\n        return deletedNode;\n    }\n\n    /**\n     * @param {Object} findParams\n     * @param {*} findParams.value\n     * @param {function} [findParams.callback]\n     * @return {LinkedListNode}\n     */\n    find({ value = undefined, callback = undefined }) {\n        if (!this.head) {\n            return null;\n        }\n\n        let currentNode = this.head;\n\n        while (currentNode) {\n            // If callback is specified then try to find node by callback.\n            if (callback && callback(currentNode.value)) {\n                return currentNode;\n            }\n\n            // If value is specified then try to compare by value.\n            if (value && this.compare.equal(currentNode.value, value)) {\n                return currentNode;\n            }\n\n            currentNode = currentNode.next;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return {LinkedListNode}\n     */\n    deleteTail() {\n        const deletedTail = this.tail;\n        \n        if (this.head === this.tail) {\n            // There is only one node in linked list.\n            this.head = null;\n            this.tail = null;\n\n            return deletedTail;\n        }\n\n        // If there are many nodes in linked list\n        // rewind to the last node and delete next link for the node before the last one.\n        let currentNode = this.head;\n        while (currentNode.next) {\n            if (!currentNode.next.next) {\n                currentNode.next = null;\n            } else {\n                currentNode = currentNode.next;\n            }\n        }\n\n        this.tail = currentNode;\n\n        return deletedTail;\n    }\n\n    /**\n     * @return {LinkedListNode}\n     */\n    deleteHead() {\n        if (!this.head) {\n            return null;\n        }\n\n        const deletedHead = this.head;\n\n        if (this.head.next) {\n            this.head = this.head.next;\n        } else {\n            this.head = null;\n            this.tail = null;\n        }\n\n        return deletedHead;\n    }\n\n    /**\n     * @param {*[]} values - Array of vaules that need to be converted to linked list.\n     * @return {LinkedList}\n     */\n    fromArray(values) {\n        values.forEach(value => this.append(value));\n    \n        return this;\n    }\n\n    /**\n     * @return {LinkedListNode[]}\n     */\n    toArray() {\n        const nodes = [];\n\n        let currentNode = this.head;\n        while(currentNode) {\n            nodes.push(currentNode);\n            currentNode = currentNode.next;\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @param {function} [callback]\n     * @return {string}\n     */\n    toString(callback) {\n        return this.toArray().map(node => node.toString(callback)).toString();\n    }\n\n    /**\n     * Reverse a linked list.\n     * @returns {LinkedList}\n     */\n    reverse() {\n        let currNode = this.head;\n        let prevNode = null;\n        let nextNode = null;\n\n        while (currNode) {\n            // Store next node.\n            nextNode = currNode.next;\n\n            // Change next node of the current node so it would link to previous node.\n            currNode.next = prevNode;\n            \n            // Move prevNode and currNode nodes one step forward.\n            prevNode = currNode;\n            currNode = nextNode;\n        }\n\n        // Reset head and tail.\n        this.tail = this.head;\n        this.head = prevNode;\n\n        return this;\n    }\n}\n\n"]}